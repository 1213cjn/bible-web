<script>
/***********************
 * 1) 工具函数
 ***********************/
const $ = (id) => document.getElementById(id);

const STORAGE_KEYS = {
  fontSize: '_font_size_px',
  favorites: '_favorites_v1',
  bibleCacheV2: '_bible_cache_v2'
};

const CACHE_VERSION = '20260224_v1'; // 你以后改数据结构时改这个版本号即可

function showToast(msg, ms = 1800) {
  const el = $('toast');
  if (!el) return;
  el.textContent = msg;
  el.classList.add('show');
  clearTimeout(showToast._timer);
  showToast._timer = setTimeout(() => el.classList.remove('show'), ms);
}

function safeJSONParse(str, fallback) {
  try { return JSON.parse(str); } catch (e) { return fallback; }
}

function normalizeVerseText(v) {
  return String(v || '').replace(/\s+/g, '');
}

function escapeHtml(str) {
  return String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

// 兼容 data/*.js 为 CommonJS: module.exports = [...]
async function loadCommonJSArray(url) {
  // 注意：这里不再强制 no-store，允许浏览器自身缓存参与加速
  const res = await fetch(url, { cache: 'default' });
  if (!res.ok) throw new Error(`加载失败: ${url}`);

  const txt = await res.text();
  const m = txt.match(/module\.exports\s*=\s*([\s\S]*?)\s*;?\s*$/);
  if (!m) {
    throw new Error(`无法解析数据文件（未找到 module.exports）: ${url}`);
  }

  // 仅用于本地受信任数据文件
  const arr = (new Function(`return (${m[1]});`))();
  if (!Array.isArray(arr)) {
    throw new Error(`数据格式错误（不是数组）: ${url}`);
  }
  return arr;
}

/***********************
 * 2) 书卷名称映射（兼容多套缩写/全名）
 ***********************/
const BOOK_NAME_CN = {
  // ===== 常见短缩写（你这类数据常见）=====
  gn:'创世记', ex:'出埃及记', lv:'利未记', nm:'民数记', dt:'申命记',
  js:'约书亚记', jg:'士师记', rt:'路得记',
  '1sm':'撒母耳记上', '2sm':'撒母耳记下',
  '1ki':'列王纪上', '2ki':'列王纪下',
  '1ch':'历代志上', '2ch':'历代志下',
  ezr:'以斯拉记', ne:'尼希米记', et:'以斯帖记',
  jb:'约伯记', ps:'诗篇', pr:'箴言', ec:'传道书', so:'雅歌',
  is:'以赛亚书', jr:'耶利米书', lm:'耶利米哀歌', ek:'以西结书', dn:'但以理书',
  hs:'何西阿书', jl:'约珥书', am:'阿摩司书', ob:'俄巴底亚书', jn:'约拿书',
  mi:'弥迦书', na:'那鸿书', hk:'哈巴谷书', zp:'西番雅书', hg:'哈该书',
  zc:'撒迦利亚书', ml:'玛拉基书',

  mt:'马太福音', mk:'马可福音', lk:'路加福音', jo:'约翰福音',
  ac:'使徒行传', rm:'罗马书',
  '1co':'哥林多前书', '2co':'哥林多后书',
  gl:'加拉太书', ep:'以弗所书', pp:'腓立比书', cl:'歌罗西书',
  '1ts':'帖撒罗尼迦前书', '2ts':'帖撒罗尼迦后书',
  '1tm':'提摩太前书', '2tm':'提摩太后书',
  tt:'提多书', phm:'腓利门书', hb:'希伯来书', jm:'雅各书',
  '1pe':'彼得前书', '2pe':'彼得后书',
  '1jo':'约翰一书', '2jo':'约翰二书', '3jo':'约翰三书',
  jd:'犹大书', re:'启示录',

  // ===== 常见缩写/全名 =====
  gen:'创世记', genesis:'创世记',
  exo:'出埃及记', exodus:'出埃及记',
  lev:'利未记', leviticus:'利未记',
  num:'民数记', numbers:'民数记',
  deu:'申命记', deuteronomy:'申命记',
  jos:'约书亚记', joshua:'约书亚记',
  jdg:'士师记', judg:'士师记', judges:'士师记',
  rut:'路得记', ruth:'路得记',
  '1sa':'撒母耳记上', '2sa':'撒母耳记下',
  '1kg':'列王纪上', '1kgs':'列王纪上', '1kings':'列王纪上',
  '2kg':'列王纪下', '2kgs':'列王纪下', '2kings':'列王纪下',
  '1chr':'历代志上', '2chr':'历代志下',
  ezra:'以斯拉记', neh:'尼希米记', nehemiah:'尼希米记', est:'以斯帖记', esther:'以斯帖记',
  job:'约伯记', psa:'诗篇', psalms:'诗篇', pro:'箴言', proverbs:'箴言',
  ecc:'传道书', ecclesiastes:'传道书', sng:'雅歌', songofsolomon:'雅歌',
  isa:'以赛亚书', isaiah:'以赛亚书', jer:'耶利米书', jeremiah:'耶利米书',
  lam:'耶利米哀歌', lamentations:'耶利米哀歌', eze:'以西结书', ezekiel:'以西结书',
  dan:'但以理书', daniel:'但以理书',
  hos:'何西阿书', hosea:'何西阿书', joe:'约珥书', joel:'约珥书',
  amo:'阿摩司书', amos:'阿摩司书', oba:'俄巴底亚书', obadiah:'俄巴底亚书',
  jon:'约拿书', jonah:'约拿书', mic:'弥迦书', micah:'弥迦书',
  nah:'那鸿书', nahum:'那鸿书', hab:'哈巴谷书', habakkuk:'哈巴谷书',
  zep:'西番雅书', zephaniah:'西番雅书', hag:'哈该书', haggai:'哈该书',
  zec:'撒迦利亚书', zechariah:'撒迦利亚书', mal:'玛拉基书', malachi:'玛拉基书',

  mat:'马太福音', matthew:'马太福音',
  mar:'马可福音', mark:'马可福音',
  luk:'路加福音', luke:'路加福音',
  jhn:'约翰福音', john:'约翰福音',
  act:'使徒行传', acts:'使徒行传',
  rom:'罗马书', romans:'罗马书',
  '1cor':'哥林多前书', '2cor':'哥林多后书',
  gal:'加拉太书', galatians:'加拉太书',
  eph:'以弗所书', ephesians:'以弗所书',
  php:'腓立比书', phil:'腓立比书', philippians:'腓立比书',
  col:'歌罗西书', colossians:'歌罗西书',
  '1ths':'帖撒罗尼迦前书', '2ths':'帖撒罗尼迦后书',
  '1tim':'提摩太前书', '2tim':'提摩太后书',
  tit:'提多书', titus:'提多书',
  phm:'腓利门书', philemon:'腓利门书',
  heb:'希伯来书', hebrews:'希伯来书',
  jas:'雅各书', james:'雅各书',
  '1pet':'彼得前书', '2pet':'彼得后书',
  '1jn':'约翰一书', '2jn':'约翰二书', '3jn':'约翰三书',
  jude:'犹大书', rev:'启示录', revelation:'启示录'
};

function getBookDisplayName(book) {
  const abbrevKey = String(book.abbrev || '').trim().toLowerCase();
  const nameKey = String(book.name || '').trim().toLowerCase();
  return BOOK_NAME_CN[abbrevKey] || BOOK_NAME_CN[nameKey] || book.name || book.abbrev || '未知书卷';
}

/***********************
 * 3) 数据层（支持本地缓存 + 后台刷新）
 ***********************/
const DB = {
  loaded: false,
  loading: false,
  loadError: null,
  loadingPromise: null,

  allBooks: [],
  index: {},
  bookMeta: [],

  _lastSource: 'none', // cache | network | none

  buildIndexAndMeta(allBooks, otLen = 39) {
    this.allBooks = Array.isArray(allBooks) ? allBooks : [];
    this.index = {};
    this.bookMeta = this.allBooks.map((b, idx) => {
      const id = String(b.abbrev || '').trim();
      if (id) this.index[id] = b;
      return {
        id,
        name: getBookDisplayName(b),
        chapterCount: Array.isArray(b.chapters) ? b.chapters.length : 0,
        testament: idx < otLen ? 'old' : 'new'
      };
    });
  },

  restoreCache() {
    const raw = localStorage.getItem(STORAGE_KEYS.bibleCacheV2);
    const cache = safeJSONParse(raw, null);
    if (!cache || cache.version !== CACHE_VERSION) return false;
    if (!Array.isArray(cache.OT) || !Array.isArray(cache.NT)) return false;

    this.buildIndexAndMeta([...cache.OT, ...cache.NT], cache.OT.length);
    this.loaded = true;
    this.loadError = null;
    this._lastSource = 'cache';
    return true;
  },

  saveCache(OT, NT) {
    try {
      const payload = {
        version: CACHE_VERSION,
        ts: Date.now(),
        OT,
        NT
      };
      localStorage.setItem(STORAGE_KEYS.bibleCacheV2, JSON.stringify(payload));
      return true;
    } catch (e) {
      // 可能超出 localStorage 容量
      console.warn('缓存写入失败:', e);
      return false;
    }
  },

  async fetchFromNetwork() {
    const [OT, NT] = await Promise.all([
      loadCommonJSArray('./data/old_testament_data_simplified.js'),
      loadCommonJSArray('./data/new_testament_data_simplified.js')
    ]);

    this.buildIndexAndMeta([...OT, ...NT], OT.length);
    this.loaded = true;
    this.loadError = null;
    this._lastSource = 'network';

    this.saveCache(OT, NT);
  },

  async init(options = {}) {
    const { preferCache = true, silent = false } = options;

    if (this.loaded && !options.forceRefresh) return;
    if (this.loadingPromise) return this.loadingPromise;

    this.loading = true;
    this.loadError = null;

    this.loadingPromise = (async () => {
      // 1) 优先恢复缓存
      if (preferCache) {
        const ok = this.restoreCache();
        if (ok && !options.forceRefresh) return;
      }

      // 2) 拉网络
      await this.fetchFromNetwork();
    })();

    try {
      await this.loadingPromise;
    } catch (err) {
      this.loadError = err;

      // 如果网络失败但已有缓存，就继续用缓存
      if (!this.loaded) {
        const restored = this.restoreCache();
        if (restored) {
          if (!silent) showToast('网络加载失败，已使用本地缓存', 2200);
          return;
        }
      }
      throw err;
    } finally {
      this.loading = false;
      this.loadingPromise = null;
    }
  },

  async ensureInit() {
    if (this.loaded) return;
    return this.init({ preferCache: true });
  },

  getBooks() {
    return this.bookMeta.slice();
  },

  getBookMetaById(bookId) {
    return this.bookMeta.find(b => b.id === bookId) || null;
  },

  getChapterVerses(bookId, chapter) {
    const b = this.index[bookId];
    if (!b) return [];

    const ch = Number(chapter);
    if (!Number.isFinite(ch) || ch <= 0) return [];

    const raw = (b.chapters && b.chapters[ch - 1]) ? b.chapters[ch - 1] : [];
    return raw.map((t, i) => ({
      verse: i + 1,
      text: normalizeVerseText(t)
    }));
  }
};

/***********************
 * 4) 收藏（本地存储）
 ***********************/
const FavoriteStore = {
  _cache: null,

  load() {
    if (this._cache) return this._cache;
    const data = safeJSONParse(localStorage.getItem(STORAGE_KEYS.favorites), []);
    this._cache = Array.isArray(data) ? data : [];
    return this._cache;
  },

  save() {
    localStorage.setItem(STORAGE_KEYS.favorites, JSON.stringify(this.load()));
  },

  keyOf(item) {
    return `${item.bookId}|${item.chapter}|${item.verse}`;
  },

  has(bookId, chapter, verse) {
    return this.load().some(it =>
      it.bookId === bookId &&
      it.chapter === Number(chapter) &&
      it.verse === Number(verse)
    );
  },

  toggle(item) {
    const arr = this.load();
    const key = this.keyOf(item);
    const idx = arr.findIndex(it => this.keyOf(it) === key);

    if (idx >= 0) {
      arr.splice(idx, 1);
      this.save();
      return false;
    } else {
      arr.unshift({
        bookId: item.bookId,
        bookName: item.bookName,
        chapter: Number(item.chapter),
        verse: Number(item.verse),
        text: item.text,
        ts: Date.now()
      });
      this.save();
      return true;
    }
  },

  list() {
    return this.load().slice().sort((a, b) => b.ts - a.ts);
  },

  remove(bookId, chapter, verse) {
    const arr = this.load();
    const key = `${bookId}|${Number(chapter)}|${Number(verse)}`;
    const idx = arr.findIndex(it => `${it.bookId}|${it.chapter}|${it.verse}` === key);
    if (idx >= 0) {
      arr.splice(idx, 1);
      this.save();
      return true;
    }
    return false;
  }
};

/***********************
 * 5) 字体设置
 ***********************/
const FontSetting = {
  min: 16,
  max: 36,
  step: 2,

  get() {
    const n = Number(localStorage.getItem(STORAGE_KEYS.fontSize));
    return Number.isFinite(n) ? Math.max(this.min, Math.min(this.max, n)) : 22;
  },

  set(px) {
    const v = Math.max(this.min, Math.min(this.max, Number(px)));
    localStorage.setItem(STORAGE_KEYS.fontSize, String(v));
    document.documentElement.style.setProperty('--font-size', v + 'px');
    if ($('fontIndicator')) $('fontIndicator').textContent = v + 'px';
    return v;
  },

  inc() { return this.set(this.get() + this.step); },
  dec() { return this.set(this.get() - this.step); }
};

/***********************
 * 6) 朗读（TTS）
 ***********************/
const TTS = {
  synth: window.speechSynthesis || null,
  voices: [],
  ready: false,
  currentKey: '',
  currentRowEl: null,
  _warnedSilent: false,

  init() {
    if (!this.synth) return;
    this.refreshVoices();

    if ('onvoiceschanged' in this.synth) {
      this.synth.addEventListener('voiceschanged', () => this.refreshVoices());
    }

    [200, 800, 1500].forEach(ms => setTimeout(() => this.refreshVoices(), ms));
    this.ready = true;
  },

  refreshVoices() {
    if (!this.synth) return;
    try {
      const list = this.synth.getVoices ? this.synth.getVoices() : [];
      if (Array.isArray(list) && list.length) this.voices = list;
    } catch (e) {}
  },

  pickVoice() {
    if (!this.voices || !this.voices.length) return null;
    const zh = this.voices.find(v => /zh|cmn/i.test(v.lang || ''));
    if (zh) return zh;
    const def = this.voices.find(v => v.default);
    return def || this.voices[0] || null;
  },

  stop() {
    if (!this.synth) return;
    try { this.synth.cancel(); } catch (e) {}
    this.clearSpeakingStyle();
    this.currentKey = '';
  },

  clearSpeakingStyle() {
    if (this.currentRowEl) {
      this.currentRowEl.classList.remove('speaking');
      this.currentRowEl = null;
    }
  },

  speak(text, key, rowEl) {
    if (!this.synth || typeof window.SpeechSynthesisUtterance === 'undefined') {
      showToast('当前浏览器不支持网页朗读（可换系统浏览器再试）', 2200);
      return;
    }
    if (!text || !text.trim()) return;

    this.stop();

    const u = new SpeechSynthesisUtterance(text);
    const voice = this.pickVoice();
    if (voice) u.voice = voice;
    u.lang = (voice && voice.lang) ? voice.lang : 'zh-CN';
    u.rate = 1.0;
    u.pitch = 1.0;
    u.volume = 1.0;

    u.onstart = () => {
      this.currentKey = key || '';
      this.clearSpeakingStyle();
      if (rowEl) {
        this.currentRowEl = rowEl;
        rowEl.classList.add('speaking');
      }
    };

    u.onend = () => {
      this.clearSpeakingStyle();
      this.currentKey = '';
    };

    u.onerror = () => {
      this.clearSpeakingStyle();
      this.currentKey = '';
      showToast('朗读失败：当前浏览器或环境限制了语音功能', 2400);
    };

    try {
      this.synth.speak(u);

      setTimeout(() => {
        if (!this.synth) return;
        const speaking = this.synth.speaking;
        const pending = this.synth.pending;
        if (!speaking && !pending && !this._warnedSilent) {
          this._warnedSilent = true;
          showToast('若无声音，请使用系统浏览器打开（微信/QQ内置浏览器常受限）', 2600);
        }
      }, 400);
    } catch (e) {
      showToast('当前环境不支持语音朗读', 2200);
    }
  }
};

/***********************
 * 7) 应用状态 + 路由
 ***********************/
const AppState = {
  view: 'loading', // loading | books | chapters | reader | favorites
  currentBookId: '',
  currentBookName: '',
  currentChapter: 1,
  history: [],

  push(viewName) {
    if (this.view && this.view !== 'loading') this.history.push(this.view);
    this.view = viewName;
    render();
  },

  go(viewName) {
    this.view = viewName;
    render();
  },

  back() {
    if (this.view === 'reader') TTS.stop();

    if (!this.history.length) {
      this.go('books');
      return;
    }

    this.view = this.history.pop();
    render();
  }
};

/***********************
 * 8) 渲染
 ***********************/
function setTopTitle(text) {
  $('topTitle').textContent = text || '微读圣经Lite Web';
}

function showOnly(viewId) {
  ['viewLoading', 'viewBooks', 'viewChapters', 'viewReader', 'viewFavorites'].forEach(id => {
    const el = $(id);
    if (el) el.classList.add('hidden');
  });
  const t = $(viewId);
  if (t) t.classList.remove('hidden');
}

function updateBooksSectionTitle(text) {
  const title = document.querySelector('#viewBooks .section-title');
  if (title) title.textContent = text;
}

function renderBooks() {
  const grid = $('bookGrid');
  if (!grid) return;

  grid.innerHTML = '';

  // 未加载：显示占位
  if (!DB.loaded) {
    updateBooksSectionTitle(DB.loading ? '请选择书卷（数据加载中…）' : '请选择书卷');

    for (let i = 0; i < 12; i++) {
      const el = document.createElement('div');
      el.className = 'book-item';
      el.style.opacity = '0.65';
      el.innerHTML = `
        <div>加载中…</div>
        <small>-- 章</small>
      `;
      grid.appendChild(el);
    }

    if (DB.loadError) {
      grid.innerHTML = `
        <div class="empty" style="grid-column:1 / -1;">
          书卷数据加载失败：${escapeHtml(DB.loadError.message || String(DB.loadError))}
          <br><br>
          请检查：data目录 / 文件名 / 通过 http(s) 打开（不要 file://）
        </div>
      `;
    }
    return;
  }

  // 已加载：真实数据
  let titleText = '请选择书卷';
  if (DB._lastSource === 'cache') titleText = '请选择书卷（已从本地缓存加载）';
  updateBooksSectionTitle(titleText);

  const books = DB.getBooks();
  books.forEach(book => {
    const el = document.createElement('div');
    el.className = 'book-item';
    el.innerHTML = `
      <div>${escapeHtml(book.name)}</div>
      <small>${book.chapterCount} 章</small>
    `;

    el.addEventListener('click', async () => {
      try {
        AppState.currentBookId = book.id;
        AppState.currentBookName = book.name;

        await renderChapters();
        AppState.push('chapters');
        $('main').scrollTop = 0;
      } catch (err) {
        console.error(err);
        showToast('打开章节失败', 2000);
      }
    });

    grid.appendChild(el);
  });
}

async function renderChapters() {
  if (!DB.loaded) {
    showToast('书卷数据加载中，请稍候…');
    await DB.ensureInit();
    renderBooks();
  }

  $('chaptersTitle').textContent = `${AppState.currentBookName} · 选择章节`;

  const meta = DB.getBookMetaById(AppState.currentBookId);
  const count = meta ? meta.chapterCount : 0;
  const grid = $('chapterGrid');
  grid.innerHTML = '';

  if (!count) {
    grid.innerHTML = `<div class="empty" style="grid-column:1 / -1;">该书卷暂无章节数据</div>`;
    return;
  }

  for (let i = 1; i <= count; i++) {
    const el = document.createElement('div');
    el.className = 'chapter-item';
    el.textContent = i;

    el.addEventListener('click', () => {
      AppState.currentChapter = i;
      renderReader();
      AppState.push('reader');
      $('main').scrollTop = 0;
    });

    grid.appendChild(el);
  }
}

function renderReader() {
  const bookId = AppState.currentBookId;
  const bookName = AppState.currentBookName;
  const chapter = AppState.currentChapter;
  const verses = DB.getChapterVerses(bookId, chapter);

  $('readerTitle').textContent = `${bookName} 第 ${chapter} 章`;

  const box = $('verseContainer');
  box.innerHTML = '';

  if (!verses.length) {
    box.innerHTML = `<div class="empty">该章节暂无数据</div>`;
    return;
  }

  verses.forEach(v => {
    const row = document.createElement('div');
    row.className = 'verse-row';
    const fav = FavoriteStore.has(bookId, chapter, v.verse);

    row.innerHTML = `
      <div class="verse-text">
        <span class="verse-no">${chapter}:${v.verse}</span>${escapeHtml(v.text)}
      </div>
      <button class="star-btn ${fav ? 'active' : ''}" type="button" aria-label="收藏">
        ${fav ? '★' : '☆'}
      </button>
    `;

    // 点击经文 -> 朗读
    row.addEventListener('click', () => {
      const speakText = `${bookName} 第${chapter}章，第${v.verse}节。${v.text}`;
      const key = `${bookId}|${chapter}|${v.verse}`;
      TTS.speak(speakText, key, row);
    });

    // 点击星标 -> 收藏/取消收藏（阻止触发朗读）
    const starBtn = row.querySelector('.star-btn');
    starBtn.addEventListener('click', (e) => {
      e.stopPropagation();

      const nowFav = FavoriteStore.toggle({
        bookId,
        bookName,
        chapter,
        verse: v.verse,
        text: v.text
      });

      starBtn.classList.toggle('active', nowFav);
      starBtn.textContent = nowFav ? '★' : '☆';
      showToast(nowFav ? '已收藏' : '已取消收藏');

      if (AppState.view === 'favorites') renderFavorites();
    });

    box.appendChild(row);
  });
}

function renderFavorites() {
  const list = FavoriteStore.list();
  $('favCountBadge').textContent = `${list.length} 条`;
  const container = $('favoriteList');
  container.innerHTML = '';

  if (!list.length) {
    container.innerHTML = `<div class="empty">暂无收藏内容</div>`;
    return;
  }

  list.forEach(item => {
    const row = document.createElement('div');
    row.className = 'verse-row';

    row.innerHTML = `
      <div class="verse-text">
        <span class="verse-no">${escapeHtml(item.bookName)} ${item.chapter}:${item.verse}</span>
        ${escapeHtml(item.text)}
      </div>
      <button class="star-btn active" type="button" aria-label="取消收藏">★</button>
    `;

    // 点击收藏项 -> 跳到对应章节并朗读
    row.addEventListener('click', async () => {
      try {
        if (!DB.loaded) {
          await DB.ensureInit();
          renderBooks();
        }

        AppState.currentBookId = item.bookId;
        AppState.currentBookName = item.bookName;
        AppState.currentChapter = item.chapter;

        renderReader();
        AppState.push('reader');
        $('main').scrollTop = 0;

        requestAnimationFrame(() => {
          const rows = Array.from(document.querySelectorAll('#verseContainer .verse-row'));
          const target = rows[item.verse - 1];
          if (target) {
            target.scrollIntoView({ behavior: 'smooth', block: 'center' });
            setTimeout(() => {
              const speakText = `${item.bookName} 第${item.chapter}章，第${item.verse}节。${item.text}`;
              TTS.speak(speakText, `${item.bookId}|${item.chapter}|${item.verse}`, target);
            }, 350);
          }
        });
      } catch (err) {
        console.error(err);
        showToast('打开收藏失败', 2000);
      }
    });

    // 取消收藏
    row.querySelector('.star-btn').addEventListener('click', (e) => {
      e.stopPropagation();
      FavoriteStore.remove(item.bookId, item.chapter, item.verse);
      renderFavorites();
      showToast('已取消收藏');
    });

    container.appendChild(row);
  });
}

function render() {
  $('btnBack').style.visibility =
    (AppState.view === 'books' || AppState.view === 'loading') ? 'hidden' : 'visible';

  $('toolbar').classList.toggle('hidden', AppState.view !== 'reader');

  if (AppState.view === 'loading') {
    setTopTitle('微读圣经Lite Web');
    showOnly('viewLoading');
    return;
  }

  if (AppState.view === 'books') {
    setTopTitle('微读圣经Lite Web');
    showOnly('viewBooks');
    return;
  }

  if (AppState.view === 'chapters') {
    setTopTitle(AppState.currentBookName || '选择章节');
    showOnly('viewChapters');
    return;
  }

  if (AppState.view === 'reader') {
    setTopTitle(`${AppState.currentBookName} ${AppState.currentChapter}章`);
    showOnly('viewReader');
    return;
  }

  if (AppState.view === 'favorites') {
    setTopTitle('收藏夹');
    showOnly('viewFavorites');
    return;
  }
}

/***********************
 * 9) 事件绑定
 ***********************/
function bindEvents() {
  $('btnBack').addEventListener('click', () => AppState.back());

  $('btnHome').addEventListener('click', () => {
    TTS.stop();
    AppState.history = [];
    AppState.go('books');
    renderBooks();
    $('main').scrollTop = 0;
  });

  $('btnFontMinus').addEventListener('click', () => {
    const v = FontSetting.dec();
    showToast(`字体 ${v}px`);
  });

  $('btnFontPlus').addEventListener('click', () => {
    const v = FontSetting.inc();
    showToast(`字体 ${v}px`);
  });

  $('btnFavorites').addEventListener('click', () => {
    renderFavorites();
    AppState.push('favorites');
    $('main').scrollTop = 0;
  });

  $('btnStopSpeak').addEventListener('click', () => {
    TTS.stop();
    showToast('已停止朗读');
  });

  document.addEventListener('visibilitychange', () => {
    if (document.hidden) TTS.stop();
  });

  window.addEventListener('pagehide', () => TTS.stop());
}

/***********************
 * 10) 启动
 * 先显示书卷界面（占位），再异步加载
 * 优先读本地缓存，下次更快
 ***********************/
async function bootstrap() {
  try {
    FontSetting.set(FontSetting.get());
    bindEvents();
    TTS.init();

    // 先显示书卷页（占位）
    AppState.go('books');
    renderBooks();

    // 第一步：优先尝试缓存（同步体验快）
    const hasCache = DB.restoreCache();
    if (hasCache) {
      renderBooks();
      // 可选提示：showToast('已从本地缓存加载', 1200);
    }

    // 第二步：后台异步刷新网络数据并更新缓存（不阻塞首屏）
    DB.init({ preferCache: false, silent: true })
      .then(() => {
        renderBooks();
        // 只有非缓存来源时再提示，避免打扰
        if (DB._lastSource === 'network') {
          // showToast('数据已更新', 1000);
        }
      })
      .catch((err) => {
        console.error(err);
        renderBooks(); // 会展示错误卡（若无缓存）
        if (!hasCache) showToast('圣经数据加载失败', 2200);
      });

  } catch (err) {
    console.error(err);
    $('viewLoading').innerHTML = `
      <div class="empty">
        初始化失败：${escapeHtml(err.message || String(err))}
      </div>
    `;
    showOnly('viewLoading');
    setTopTitle('加载失败');
  }
}

bootstrap();
</script>
